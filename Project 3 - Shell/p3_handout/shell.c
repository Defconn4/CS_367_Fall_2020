/* This is the only file you should update and submit. */

/* Fill in your Name and GNumber in the following two comment fields
 * Name: Frankie Costantino
 * GNumber: G01132886
 */

/* Final project yay and ;(! */
#include "shell.h"
#include "parse.h"

/* Constants */
#define DEBUG 0
//static const char *shell_path[] = { "./", "/usr/bin/", NULL };
static const char *built_ins[] = { "quit", "help", "kill", "fg", "bg", "jobs", NULL};

/* Struct definition for command typed in by user in shell */
typedef struct command_struct {
	int job_id;		/* Job ID assigned on creation */
	int control;		/* Specifies control operators, 1 = && / 2 = || */
	pid_t pid;		/* Process ID for each job (generated by Kernel) */
	char *exec_status;	/* Stopped || Running */
	char *cmd;		/* Command from user without the \n */
	struct command_struct *next;
} Command;


/* Singly Linked List Struct Definition */
typedef struct process_list {
	Command *head;		/* Head of Singly Linked List */
	int count;		/* Number of jobs in the list */
} List;


/* Shell Job Lists Struct Definition */
typedef struct shell_jobs {
	List *fg_list;		/* Foreground (fg) Processes */
	List *bg_list;		/* Background (bg) Processes */
} Jobs;


/* Function Prototypes */
Jobs *shell_init();
void shell_free();
void dealloc_lists(Command *head);
void handle_non_built_ins(char *arguments[], char *arguments2[], int is_bg, int is_append, int control, char *in_file, char *out_file);
void handle_file_redirection(char *arguments[], int is_bg, int is_append, char *in_file, char *out_file);
int exec_file_redirection(char *arguments[], int fd, int io, char *cwd, char *usr_bin);
int mult_redirects(char *arguments[], int fd_in, int fd_out, char *cwd, char *usr_bin);
Command *command_generate(char *cmd, int is_bg, int control);
void free_command_fg();
void free_command_bg(Command *command);
void handle_control_operators(char *arguments[], char *arguments2[], char *cwd, char *cwd2, char *usr_bin, char *usr_bin2, int is_bg, int control);
void handle_bg_control_operators(char *arguments[], char *arguments2[], char *cwd, char *cwd2, char *usr_bin, char *usr_bin2, int is_bg, int control);
void built_in_jobs();
void built_in_kill(char *argv[]);
void built_in_fg(char *argv[]);
void built_in_bg(char *argv[]);

/* Prototypes for Signal Handlers */
void sigint_handler(int sig);
void sigtstp_handler(int sig); 
void sigchld_handler(int sig);

/* Linked List Functions */
void add_job(Command *command, int is_bg);
void move_fg_bg_append();
Command *get_bg_job();
Command *get_bg_job_pid(pid_t pid);
void remove_bg_job(pid_t pid);

/* ---------------------------------------MAIN CODE IS BELOW--------------------------------------------------- */

// Declare global job list called shell.
Jobs *shell;
	
// Global int tally for background jobs (unique job_ids).
static int bg_job_id = 1;

// Global pointer reference for argv2 and command paths for background control operations.
char *g_argv2[MAXARGS];
char g_cwd2[MAXLINE];
char g_usr_bin2[MAXLINE];

// Global variables for handling background control operators.
int g_control = 0;
char *g_cmd = NULL;
int g_pid = 0;
	
/* The entry of your shell program */
int main() {
	char cmdline[MAXLINE];        /* Command line */
	char *cmd = NULL;
	g_cmd = malloc(sizeof(char) * MAXLINE);
	
	// Initialize our shell structure.	
	shell = shell_init();
	
	/* Intial Prompt and Welcome */
	log_prompt();
	log_help();
	
	/* Shell looping here to accept user command and execute */
	while (1)
	{
		// Install signal handler for Control-C (^C).
		// NOTE: This is installed here because when we first enter the shell/after a job we can handle ^C.
		// We don't need a struct for old Control-C settings since we are overriding the default functionality.
		struct sigaction new_c;
		memset(&new_c, 0, sizeof(new_c));
		new_c.sa_handler = sigint_handler;
		sigaction(SIGINT, &new_c, NULL);
		
		// Install signal handler for Control-Z (^Z).
		struct sigaction new_z;
		memset(&new_z, 0, sizeof(new_z));
		new_z.sa_handler = sigtstp_handler;
		sigaction(SIGTSTP, &new_z, NULL);
			
		// Install signal handler for SIGCHLD signals (when a child terminates).
		struct sigaction child;
		memset(&child, 0, sizeof(child));
		child.sa_handler = sigchld_handler;
		sigaction(SIGCHLD, &child, NULL);
	
		char *argv[MAXARGS], *argv2[MAXARGS];     /* Argument list */
		Cmd_aux aux;                /* Auxilliary cmd info: check parse.h */

		/* Print prompt */
		log_prompt();

		/* Read a line */
		// note: fgets will keep the ending '\n'
		if (fgets(cmdline, MAXLINE, stdin) == NULL) 
		{
			if (errno == EINTR)
			continue;
			exit(-1);
		}

		if (feof(stdin)) /* ctrl-d will exit shell */
		{
			exit(0);
		}

		/* Parse command line */
		if (strlen(cmdline)==1)   /* empty cmd line will be ignored */
		continue;     

		cmdline[strlen(cmdline) - 1] = '\0';        /* remove trailing '\n' */

		cmd = malloc(strlen(cmdline) + 1);
		snprintf(cmd, strlen(cmdline) + 1, "%s", cmdline);
		
		/* Bail if command is only whitespace */
    		if(!is_whitespace(cmd))
		{
      			initialize_argv(argv);    /* initialize arg lists and aux */
      			initialize_argv(argv2);
      			initialize_aux(&aux);
      			parse(cmd, argv, argv2, &aux); /* call provided parse() */

      			if (DEBUG)  /* display parse result, redefine DEBUG to turn it off */
        		debug_print_parse(cmd, argv, argv2, &aux, "main (after parse)");

      			/* After parsing: your code to continue from here */
      			/*================================================*/
			
			// Copy all elements from argv2 to g_argv2.
			int i = 0;
			for(i = 0; i < MAXARGS; i++)
			{
				if(argv2[i] == NULL) { break; }
				g_argv2[i] = malloc(sizeof(char));	
				strcpy(g_argv2[i], argv2[i]);
			}
			
			// Add null terminator to array.
			g_argv2[i] = NULL;
			
			// Support built-in function "quit".
			// argv[0] is "quit" command.
			if(strcmp(argv[0], built_ins[0]) == 0)
			{
				// Call log_quit() to print out predefined information and exit the shell.
				log_quit();
				exit(EXIT_SUCCESS);
			}
			
			// Support built-in function "help".
			if(strcmp(argv[0], built_ins[1]) == 0)
			{
				// Call log_help() to print out predefined information.
				log_help();
				continue;
			}
			
			// Support built-in function "kill".
			if(strcmp(argv[0], built_ins[2]) == 0)
			{
				// Handle "kill" command.
				built_in_kill(argv);	
				continue;
			}
			
			// Support built-in function "fg".
			if(strcmp(argv[0], built_ins[3]) == 0)
			{
				// Call helper function to handle commnad.
				built_in_fg(argv);
				continue;
			}
			
			// Support built-in function "bg".
			if(strcmp(argv[0], built_ins[4]) == 0)
			{
				// Call helper function to handle command.
				built_in_bg(argv);		
				continue;
			}
		
			// Support built-in function "jobs".
			if(strcmp(argv[0], built_ins[5]) == 0)
			{
				// Handle built-in jobs.
				built_in_jobs();
				continue;
			}
			
			// Create command from user input.
			Command *command = command_generate(cmd, aux.is_bg, aux.control);
			
			// If the command we created was NULL, loop back again to restart.
			if(command == NULL) { continue; }
			
			// Add our job to bg or fg job list.
			add_job(command, aux.is_bg);	
			
			// Handle non-built-in commands.
			handle_non_built_ins(argv, argv2, aux.is_bg, aux.is_append, aux.control, aux.in_file, aux.out_file);
			
		}

		free_options(&cmd, argv, argv2, &aux);
	}
	
	// Return from main.
	return 0;
}

/* Function for handling the built-in command "fg".
 * Switches the specified background to the foreground and then wait until it completes. */
void built_in_fg(char *argv[]) {
	
	// Grab the job_id from argv.
	int job_id = atoi(argv[1]);
	
	// If the background list is empty, invalid job id.
	if(shell -> bg_list -> head == NULL)
        {
		// Call logging function for invalid job id.
		log_jobid_error(job_id);
		return;
        }
	
	// Check if the head of the bg_job list is matching job.
	if(shell -> bg_list -> head -> job_id == job_id)
	{
		// Call the logging function to indicate this is happening.
		log_job_fg(shell -> bg_list -> head -> pid, shell -> bg_list -> head -> cmd);
		
		// Grab the removed head.
		Command *rem = shell -> bg_list -> head;
		
		// Set the next reference for the bg head to its next.
		shell -> bg_list -> head = shell -> bg_list -> head -> next;
		
		// Decrement the amount of jobs in the bg list.
		shell -> bg_list -> count--;
		
		// Make sure the head of the foreground job list is NULL.
		shell -> fg_list -> head = NULL;
	
		// Place the old background job as the new foreground job.
		rem -> next = shell -> fg_list -> head;
		shell -> fg_list -> head = rem;
		
		// If the job was previously stopped before being moved, send a SIGCONT signal to it.
		if(strcmp(shell -> fg_list -> head -> exec_status, "Stopped") == 0)
		{
			kill(shell -> fg_list -> head -> pid, SIGCONT);
		}
		
		while(shell -> fg_list -> head != NULL)
		{
			// Do nothing
		}
		
		return;			
	}	
	
	// Search background job list for the job with the given job_id.
	Command *head = shell -> bg_list -> head;
	while(head != NULL)
	{
		// If we found the matching job id.
		if(head -> next -> job_id == job_id)
		{
			// Call logging function.
			log_job_fg(head -> next -> pid, head -> next -> cmd);
			
			// Grab the removed job.
			Command *rem = head -> next;
			
			// Remove the job from the bg job list.
			head -> next = head -> next -> next;
			
			// Decrement the number of jobs in the bg list.
			shell -> bg_list -> count--;
			
			// Make sure the head of the foreground job list is NULL.
			shell -> fg_list -> head = NULL;
		
			// Place the old background job as the new foreground job.
			rem -> next = shell -> fg_list -> head;
			shell -> fg_list -> head = rem;
			
			// If the job was previously stopped before being moved, send a SIGCONT signal to it. 
			if(strcmp(shell -> fg_list -> head -> exec_status, "Stopped") == 0)
			{
				kill(shell -> fg_list -> head -> pid, SIGCONT);
			}
		
			while(shell -> fg_list -> head != NULL)
			{
				// Do nothing.
			}
			
			return;
		}	
	
		head = head -> next;	
	}
	
	// If we could not find the matching job_id, call job_id error log.
	log_jobid_error(job_id);		
			
}

/* Function for handling the built-in command "bg".
 * Resumes the execution of a background job with the specified job_id.
 */
void built_in_bg(char *argv[]) {

	// Grab the job id.
	int job_id = atoi(argv[1]);
	
	// If the background job list is empty.
	if(shell -> bg_list -> head == NULL)
	{
		// Call the log jobid error.
		log_jobid_error(job_id);
		return;
	}
	
	// If the head of the list is the job to be continued.
	if(shell -> bg_list -> head -> job_id == job_id)
	{
		// If the job is already running, call the log jobid error.
		if(strcmp(shell -> bg_list -> head -> exec_status, "Running") == 0)
		{
			return;	
		}
		
		// Otherwise, set the exec_status to "Running" and call a SIGCONT on it.
		strcpy(shell -> bg_list -> head -> exec_status, "Running");
		kill(shell -> bg_list -> head -> pid, SIGCONT);
		
		// Call the logging function to say we used "bg" command.
		log_job_bg(shell -> bg_list -> head -> pid, shell -> bg_list -> head -> cmd);
		
		return;
	}
	
	// Else, search the list of background jobs for the correct one.
	Command *head = shell -> bg_list -> head;
	while(head != NULL)
	{
		if(head -> job_id == job_id)
		{
			// If the job is already running, do nothing.
			if(strcmp(head -> exec_status, "Running") == 0)
			{
				return;
			}
			
			// Otherwise, we can set the exec_status to running and call a SIGCONT on it.
			strcpy(head -> exec_status, "Running");
			kill(head -> pid, SIGCONT);
			
			// Call the logging function to say we used "bg" command.
			log_job_bg(head -> pid, head -> cmd);
			
			return;
		}
		
		head = head -> next;	
	}
	
	
	// If we reach this point, the job id was not found.
	log_jobid_error(job_id);
	return;
}

/* Function for handling built-in command "kill".
 * NOTE: kill() does not "kill" it a process, it sends a signal to a process and
 * we handle that signal from there.
 * KILL() IS ONLY USED ON BACKGROUND PROCESSES.
 */
void built_in_kill(char *argv[]) {
	
	// If argv is NULL, return to main.
	if(argv == NULL) { return; }
			
	// Grab the signal we need to send and the pid of the process.
	// Convert arguments to integer.
	int sig = atoi(argv[1]);
	pid_t pid = atoi(argv[2]);
	
	// Use kill() to send our signal to the process.
	kill(pid, sig);
			
	// Call logging function to report the kill command has been received and activated.
	log_kill(sig, pid);
			
	return;
}			

/* Function for handling built-in command "jobs". */
void built_in_jobs() {
	
	// Report the number of background jobs.
	log_job_number(shell -> bg_list -> count);
		
	// Iterate through our list of bg jobs.
	Command *head = shell -> bg_list -> head;
	while(head != NULL)
	{
		// Call logging function for each bg job.
		log_job_details(head -> job_id, head -> pid, head -> exec_status, head -> cmd);
		
		head = head -> next;
	}
	
	return;
}

/* Add a job to appropriate list of jobs (foreground or background). */
void add_job(Command *command, int is_bg) {
	
	// If command is NULL, return to main.
	if(command == NULL) { return; }
	
	// If we have a foreground job, make new command the head of the foreground list.
	// ONLY add to the list if the head of the fg list NULL, indicating it is empty.
	if(shell -> fg_list -> head == NULL && is_bg == 0)
	{
		command -> next = shell -> fg_list -> head;
		shell -> fg_list -> head = command;
		
		// Increment the number of fg jobs in the fg job list.
		shell -> fg_list -> count += 1;
		return;
	}
	
		
	// If the bg job list is empty, insert our bg job at the beginning of bg job list.
	if(is_bg == 1 && shell -> bg_list -> head == NULL)
	{
		command -> next = shell -> bg_list -> head;
		shell -> bg_list -> head = command;
		
		// Increment the number of bg jobs in the list.
		shell -> bg_list -> count += 1;
		return;	
	}

	// If we need to append the background job to the end of the list.
	if(is_bg == 1 && shell -> bg_list -> head != NULL)
	{
		// Find the previous job id to increment for use in our new job.
		int prev_job_id = 0;
                Command *cur = shell -> bg_list -> head;
                while(cur != NULL)
                {
                        if(cur -> next == NULL)
                        {
                                prev_job_id = cur -> job_id;
                        }

                        cur = cur -> next;
                }
		
		// Increment previous job id.
		prev_job_id++;
		
		// Append to the end of the bg job list.
		Command *head = shell -> bg_list -> head;
		
		// Iterate until we read the end of the list.
		while(head != NULL && head -> next != NULL) { head = head -> next; }
		
		// Append our new command to the end.
		head -> next = command;

		// Set the job id our command.
                command -> job_id = prev_job_id;
		
		// Increment the count for bg list.
		shell -> bg_list -> count += 1;
		return;
	}
	
	return;
} 

/* Moves the foreground job to the background upon receiving a ^Z signal. */
void move_fg_bg_append() {
	
	// Save our foreground command (grab head before removal).
	Command *fg = shell -> fg_list -> head;
	
	// Remove the head of the foreground list.
	// The next will be NULL.
	shell -> fg_list -> head = shell -> fg_list -> head -> next;
	
	// Decrement the number of items in the fg job list.
	shell -> fg_list -> count--;
	
	// Change fg's exec status to "Stopped".
	strcpy(fg -> exec_status, "Stopped");
	
	// If the background list is empty, make the fg job the head of the bg list.
	if(shell -> bg_list -> head == NULL)
	{
		fg -> next = shell -> bg_list -> head;
		shell -> bg_list -> head = fg;
		
		// Increment the count of bg jobs.
		shell -> bg_list -> count += 1;
	
		// Set the job_id of the background job to one since it's the head.
		fg -> job_id = 1;
		
		return;
	}
	
	
	// If the background list is NOT empty, we need to move the foreground job into	the next available spot.
	// Save the head of the bg_list.
	Command *head = shell -> bg_list -> head;
	
	// Iterate until through the bg_list until we find where the NEXT is equal to NULL,
	// then we will add our new value there (appending).
	while(head -> next != NULL)
	{
		head = head -> next;
	}
	
	// Find the previous node's job ID, save it and add 1 to it for the next job id.	
	// Save the prev node's job id (head is prev node).
	int prev_job_id = head -> job_id;
	
	// Add one to the previous node's job id.
	prev_job_id++;
	
	// Append our job to the end of the list.
	head -> next = fg;
	
	// Make our new background job's next point to the new end of the linked list.
	head -> next -> next = NULL;
	
	// Increment the size of the bg_list.
	shell -> bg_list -> count += 1;
		
	// Set the job_id for fg to the next available integer.
	fg -> job_id = prev_job_id;
	
	// Increment the bg_job_id counter.
	bg_job_id += 1;
	
	return;
}

/* Handler for SIGTSTP (contrl-z) keyboard interruptions. */
void sigtstp_handler(int sig) {
	
	// If there is no foreground job to stop and move to the background, ignore the stop signal.
	if(shell -> fg_list -> head == NULL)
	{
		log_ctrl_z();
		return;
	}
	
	// Else, if there is a foreground process to move to the background.
	log_ctrl_z();
	
	// Send the SIGTSTP signal to the process to indicate it must stop.
	kill(shell -> fg_list -> head -> pid, sig);
	
	return;
}

/* Handler for SIGINT (control-c) keyboard interruptions. */ 
void sigint_handler(int sig) {
	
	// If there is no foreground job to kill, ignore the kill signal.
	if(shell -> fg_list -> head == NULL)
	{
		// Call the appropriate logging function.
		log_ctrl_c();
		return;
	}
	
	// Else, if there is a foreground process in play...
	log_ctrl_c();
			
	// Send the SIGINT signal the process with patching pid.
	kill(shell -> fg_list -> head -> pid, sig);
	
	return;
}

/* Handler for SIGCHLD signals, so we know how they terminated. */
void sigchld_handler(int sig) {
	
	// If we are handling a foreground job...
	if(shell -> fg_list -> head != NULL)
	{
		// Save the fg job for less typing and initialize its child status.
		Command *command = shell -> fg_list -> head;
		int child_status;
		
		// Wait for the child with the given pid to terminate.
		// We use the option WUNTRACED so we can see if the child was terminated by a signal (^C or ^Z).
		while( (command -> pid = (waitpid(command -> pid, &child_status, WUNTRACED | WCONTINUED))))
		{
			// If pid is invalid, we need to reloop.
			if(command -> pid == -1) { continue; }	
			
			// If the child terminated normally, we can call the logging function and remove the command
			// from our data structure.
			if(WIFEXITED(child_status))
			{	
				// Set the job's execution status to "Stopped".
				strcpy(command -> exec_status, "Stopped");
				
				// Call the log function to indicate this process is done
				// and free the memory for the command.	
				log_job_fg_term(command -> pid, command -> cmd);
				free_command_fg();
				
				return;
			}
			
			// If the child was terminated by a signal.
			if(WIFSIGNALED(child_status))
			{
				// If the child was terminated by ^C (SIGINT).
				if(WTERMSIG(child_status) == SIGINT)
				{
					// Indicate the process has been killed.
					log_job_fg_term_sig(command -> pid, command -> cmd);
				
					// Remove the head of the fg job list (since next is NULL).
					free_command_fg();
					
					return;
				}
			}
				
			// If the process was stopped by a signal.
			if(WIFSTOPPED(child_status))
			{
				// If the child was stopped by ^Z (SIGTSTP).
				if(WSTOPSIG(child_status) == SIGTSTP)
				{		
					// Call logging function to display to shell that we are moving this process to the background.
					// NOTE: Use this in conjuction with "jobs" to see that this process moved to the background.
					log_job_fg_stopped(command -> pid, command -> cmd);
	
					// Call helper function to move foreground job to background.
					move_fg_bg_append();

					return;	
				}		
			}
			
			// If the process was continued by a signal (for use with the command "fg").
			if(WIFCONTINUED(child_status))
			{
				
				// Change the foreground command's exec status to "Running".
				strcpy(command -> exec_status, "Running");
				
				// Call logging function to display that the foreground process has been continued.
				log_job_fg_cont(command -> pid, command -> cmd);
				return;
			}
		}		
	}
		
	// If we are handling a background job (is there is 1 or more background jobs in the list).
	if(shell -> bg_list -> count >= 1)
	{
		// Save the pid of our child to be reaped.
		pid_t pid;
		
		// Save child status in case a background child dies from kill().
		int child_status;
		
		// Use waitpid with the WNOHANG option, which prevents the handler from blocking the terminal.
		while((pid = waitpid(-1, &child_status, WNOHANG | WUNTRACED | WCONTINUED)) > 0)
		{
			// If pid is invalid, we need to reloop.
			if(pid == -1) { continue; }
			
			// Grab our current background command from our list of background jobs.
			// Since it was reaped at this point, decrement the job id count to ensure it starts at the 
			// correct number.	
			Command *command = get_bg_job_pid(pid);
			if(bg_job_id > 1) { bg_job_id--; }
			
			// If our command is NOT NULL on the first reap, we grab the necessary information
			// from it to handle control operators in the background. 
			// sigchld_handler	
			if(command != NULL)
			{	
				// Grab the control (1 or 2), cmd, and pid.
				g_control = command -> control;
				strcpy(g_cmd, command -> cmd);
				g_pid = command -> pid;
			}
			
			// If the child terminated normally, call the logging function and remove the child from the data structure.
			if(WIFEXITED(child_status))
			{
				// If the command is not NULL for the 2nd time around we can execute the next job in the control cmd.
				if(command != NULL && g_control != 0)
				{
					// Recreate the command and add it to to the job list.
					Command *command2 = command_generate(g_cmd, 1, g_control);
					
					// If the child exited abnormally (exit code other than 0).
					if(WEXITSTATUS(child_status) == 1)
					{	
						// If we have ||, and the exit code was 1 for the first command, execute the 2nd command.	
						if(command2 -> control == 2)
						{
							
							// Grab child status, fork(), and check fork() status.
							int child_status_or2;
							pid_t pid2 = fork();
							if(pid2 == -1) { return; }
							
							// Execute command in child.
							if(pid2 == 0)
							{
								// Change the process group of the child.
								int pgid = setpgid(0,0);
								if(pgid < 0) { return; }

								if(execv(g_cwd2, g_argv2) < 0)
								{
									if(execv(g_usr_bin2, g_argv2) < 0)
									{
										log_command_error(command -> cmd);
										exit(1);
									}
								}
							}
							
							// Handle child.
							else
							{	
								// Call the continuation of the OR command.
								log_or_list(command -> pid, pid2, command -> cmd);
								
								// When the child exits, handle elsewhere.
								if(WIFEXITED(child_status_or2))
								{
									return;
								}
							
							}
						}
						
						// If we have &&, and the first command exited with code 1, DO NOT run the 2nd command.
						if(command2 -> control == 1)
						{
							// Indiciate the 2nd command will not be run.
							log_and_list(command -> pid, -1, command -> cmd);
							
							// Indicate the command has terminated.
							log_job_bg_term(command -> pid, command -> cmd);
							
							// Remove the command from the background job list.
							remove_bg_job(command -> pid);
							free_command_bg(command);

							return;
						}
							
							
						return;
					}
						
					//sigchld_handler
					// If the child exited with code 0 (normally).
					if(WEXITSTATUS(child_status) == 0)
					{	
						// || => first command terminates normally, we DO NOT execute the 2nd command.
						if(command -> control == 2)
						{
							// Indicate the 2nd command will not be run.
							log_or_list(command -> pid, -1, command -> cmd);
							
							// Indicate the command has terminated.
							log_job_bg_term(command -> pid, command -> cmd);
							
							// Remove the command from the background job list.
							remove_bg_job(command -> pid);
							free_command_bg(command);
						
							return;
						}	
						
						// && => first command termiantes normally, we DO execute the 2nd command.
						if(command -> control == 1)
						{
							// Child status for 2nd fork() for &&.
							int child_status_and2;
								
							// Fork() for the 2nd command.
							pid_t pid2 = fork();
							
							// Upon fork() failure, return.
							if(pid == -1) { return; }
							
							// Run the command in the child.
							if(pid2 == 0)
							{
								// Create a new process group for this child.
								int pgid2 = setpgid(0,0);
								if(pgid2 < 0) { return; }
								
								// Run the 2nd command.
								if(execv(g_cwd2, g_argv2) < 0)
								{
									if(execv(g_usr_bin2, g_argv2) < 0)
									{
										log_command_error(command -> cmd);
										exit(1);
									}
								}	
							}	
							// Else, handle child in parent.
							else
							{
								// Indicate 2nd process has started for &&.
								log_and_list(command -> pid, pid2, command -> cmd);
							
								// See if the command exited normally.
								// If it does, we exit and handle elsewhere.
								if(WIFEXITED(child_status_and2)) { return; }
							}
						
						}
						
					}	
				}
						
				
				// If we have a null command and control operators, we know our command is done.
				if(command == NULL && g_control != 0)
				{
					// Call the end of the job.
					log_job_bg_term(g_pid, g_cmd);
			
					// If the background job list is empty, ensure the head of the list stays NULL.
					if(shell -> bg_list -> count == 0)
                       	                {
                               	        	shell -> bg_list -> head = shell -> bg_list -> head -> next;
						bg_job_id = 1;
                                       	}
					
					
					// Remove the job the bg job list.	
					remove_bg_job(g_pid);
					
					return;
				}	
				
				// If we have a normal background job with no control operators (thank god).
				if(command != NULL && g_control == 0)
				{
					
					// Call the logging function to indicate the process is done.
					log_job_bg_term(command -> pid, command -> cmd);
				
					// Remove the background command from the bg list.
					remove_bg_job(pid);
			
					// Deallocate memory for the command.
					free_command_bg(command);
					
					return;
				}
				
				return;
			}
			
		// If we were terminated by a signal (SIGINT = 2) or (SIGKILL = 9) from kill() command.	
		if(WIFSIGNALED(child_status))
		{
			// Let the user know this process has been terminated by a signal.
			log_job_bg_term_sig(pid, command -> cmd);
			
			// Find the PID of the process we need to terminate.
			// If the head of background jobs list is the one to be terminated.
			if(shell -> bg_list -> head -> pid == pid)
			{	
				// Move head reference over.
				shell -> bg_list -> head = shell -> bg_list -> head -> next;
				
				// Decrement the number of jobs in the list.
				shell -> bg_list -> count--;
				
				return;
			}
			
			// Search through the background job list to get find the correct pid to move.
			Command *head = shell -> bg_list -> head;
			while(head != NULL)
			{	
				// If the next node is the one we are looking for.
				if(head -> next -> pid == pid)
				{
					// Move the next reference of our current over the next node.
					head -> next = head -> next -> next;
					
					// Decrement the number of jobs in the list.
					shell -> bg_list -> count--;
					
					return;	
				}
				
				head = head -> next;
			}
					 
			return;	
		}
		
		// If the child was signaled to continue (SIGCONT = 18).
		if(WIFCONTINUED(child_status))
		{
			// Let the user know the job has continued.
			log_job_bg_cont(pid, command -> cmd);
			
			// Search for the correct process to set executation state to "Running" on.
			// See if it's the head.
			if(shell -> bg_list -> head -> pid == pid)
			{
				strcpy(shell -> bg_list -> head -> exec_status, "Running");
				return;
			}
			
			// Search through the list until we find the correct pid.
			Command *head = shell -> bg_list -> head;
			while(head != NULL)
			{
				if(head -> pid == pid)
				{
					strcpy(head -> exec_status, "Running");
					return;
				}
				
				head = head -> next;
			}
			
			return;
		}
		
		// If the child was signaled to STOP (SIGTSTP = 20).
		if(WIFSTOPPED(child_status))
		{
			// Let the user know the job has been stopped.
			log_job_bg_stopped(pid, command -> cmd);
			
			// Find the correct process to changed exec status of.
			if(shell -> bg_list -> head -> pid == pid)
			{
				strcpy(shell -> bg_list -> head -> exec_status, "Stopped");
				return;
			} 
			
			// Search through the list until we find the correct pid.
			Command *head = shell -> bg_list -> head;
			while(head != NULL)
                        {
                        	if(head -> pid == pid)
                                {
                                	strcpy(head -> exec_status, "Stopped");
                                        return;
                               	}
				
				head = head -> next;
                        }
			
			return;
		}
	}
}
}	

/* Remove the command with the given PID from the list of background jobs. */
void remove_bg_job(pid_t pid) {
	
	// If the head of the background list is the job to be removed...
	if(shell -> bg_list -> head -> pid == pid)
	{
		// Shift the head to be the next item in the list.
		shell -> bg_list -> head = shell -> bg_list -> head -> next;
		
		// Decrement the count of items in the background job list.
		shell -> bg_list -> count -= 1;
		
		// Set the bg_job_id count to 1.
		bg_job_id = 1;
		
		return;
	}
	
	// If the head of the list is not the one to be removed, then we need to find the
	// command with the matching pid.
	Command *head = shell -> bg_list -> head;
	
	while(head -> next != NULL)
	{
		// If the next node in the sequence has the matching pid, we want our current
		// node's next pointer to point to current's next's next to cut out head -> next. 
		if(head -> next -> pid == pid)
		{
			head -> next = head -> next -> next;
			
			// Decrement the count of background jobs.
			shell -> bg_list -> count -= 1;
			
			return;
		}		
	
		// Move to next node.
		head = head -> next;
	}
	
	return;

}


/* Grab the background job with the matching pid.
 * Returns the background job on success, NULL otherwise.
 */
Command *get_bg_job_pid(pid_t pid) {

	// If the head of the background jobs list has the matching pid...
	if(shell -> bg_list -> head -> pid == pid)
	{
		// Return the head.
		return shell -> bg_list -> head;
	}
	
	// Else, we need to search through the bg job list for the matching pid.
	Command *head = shell -> bg_list -> head;
	while(head -> next != NULL)
	{
		if(head -> next -> pid == pid)
		{
			return head -> next;	
		}
		
		head = head -> next;
	}

	return NULL;
}

/* Initialize our underlying data structure for our shell.
 * Returns a pointer to the new Job data structure or NULL on any error.
 */
Jobs *shell_init() {
	
	// Allocate memory for Jobs structure.
	// If memory cannot be properly allocated, return NULL.
	Jobs *shell = (Jobs *) malloc(sizeof(Jobs));
	if(shell == NULL) { return NULL; }
	
	// Allocate memory for fg and bg List inside Job shell.
	shell -> fg_list = (List *) malloc(sizeof(List));
	shell -> bg_list = (List *) malloc(sizeof(List));
	
	// Check that the fg or bg List has been properly allocated. If not return NULL.
	if( (shell -> bg_list) == NULL || (shell -> fg_list) == NULL) { return NULL; }
	
	// Set the # of jobs for fg and bg List to 0 to begin.
	shell -> fg_list -> count = 0;
	shell -> bg_list -> count = 0;
	
	// Initialize head pointer to NULL for fg and bg Lists.
	shell -> fg_list -> head =  NULL;
	shell -> bg_list -> head = NULL;
	
	return shell;
}

/* Create a new Command with the given information.
 * NOTE: bg_job_id is a gloabl static variable..
 * Returns the Command on success or NULL on any error.
 */
Command *command_generate(char *cmd, int is_bg, int control) {
	
	// If cmd is NULL, return to main.
	if(cmd == NULL) { return NULL; }
	
	// Allocate memory for our Command struct, exec_status and cmd fields.
	Command *command = NULL;
	command = (Command *) malloc(sizeof(Command));
		
	memset(command, 0, sizeof(Command));
	command -> exec_status = (char *) malloc(sizeof(char) *	MAXLINE);	// Note: MAXLINE constant is 100 characters.
	command -> cmd = (char *) malloc(sizeof(char) * MAXLINE);		// This holds our command line argument from our user.
		
	// Ensure memory allocation was successful, return NULL if not.
	if((command == NULL) || (command -> exec_status) == NULL || (command -> cmd) == NULL )
	{
		return NULL;
	}
	
	// Set the control for the command.
	command -> control = control;
		
	// Set Command fields job_id, exec_status, cmd, and next.
	// For job_id, we set the id based on if the command will run a BG job or FG job. FG job means the the job_id = 0, BG job = 1,2,3,4, etc...
	if(is_bg == 0) { command -> job_id = 0; }
	else if(is_bg == 1)
	{
		// Set job id and increment it.
		command -> job_id = bg_job_id;
		bg_job_id += 1; 
	}
	
	// Set exec_status, cmd, and next. NOTE: PID will be set in the handle_non_built_ins(...) function.
	strcpy(command -> exec_status, "Running");
	strcpy(command -> cmd, cmd);
	command -> next = NULL;	
	
	return command;
}

/* Helper function for handle_file_redirection() that executes the jobs associated with file redirection.
 * NOTE: io is an integer flag that indicates which specified method we used for file redirection (1 = >, 2 = >>, 3 = <).
 * Return -1 on invalid command failure, or 0 on otherwise. We don't care about the return value for success though.
 */
int exec_file_redirection(char *arguments[], int fd, int io, char *cwd, char *usr_bin) {
	
	// If any of the pointer arguments are NULL, we want to return an error.
	if(arguments == NULL || cwd == NULL || usr_bin == NULL) { return -1; }
			
	// Backup for STDOUT and STDIN streams.
	int backup = -1;
	
	// If we are using ">" or ">>" (changing STDOUT) for file redirection.
	if(io == 1 || io == 2)
	{
		// Use dup() to make a copy of STDOUT_FILENO before changing it.
		backup = dup(STDOUT_FILENO);
			
		// Change the standard output to file descriptor.
		dup2(fd, STDOUT_FILENO);
		
	}
	
	// If we are using "<" (changing STDIN) for file redirection.
	if(io == 3)
	{
		// Use dup() to make a copy of STDIN_FILENO before changing it.
		backup = dup(STDIN_FILENO);
			
		// Change the standard input to file descriptor.
		dup2(fd, STDIN_FILENO);
	}
	
	
	// We need to check in order: /. then /usr/bin/.
	// First, execute with current directory, and see if that doesn't work.
	// If it does work, we can return from this function.
	if(execv(cwd, arguments) < 0)
	{
		if(execv(usr_bin, arguments) < 0)
		{
			// Make to correctly replace our changed output/input stream before returning.
			if(io == 1 || io == 2) { dup2(backup, STDOUT_FILENO); }
			else if(io == 3) { dup2(backup, STDIN_FILENO); }
			return -1;
		}
	}
	
	return 0;
}

/* Function for handling file redirection w/ non-built-in commands. */
void handle_file_redirection(char *arguments[], int is_bg, int is_append, char *in_file, char *out_file) {
		
		// If arguments is NULL, return to main.
		if(arguments == NULL) { return; }
			
		// Always grab the background job.
		Command *command = get_bg_job();
		
		// If we are trying to execute a background job and it's NULL, return to main.
		if(is_bg == 1 && command == NULL) { return; }

		// String for our current working directory and /usr/bin/ & concatentation of user command.
		char cwd[MAXLINE] = "./";
		char usr_bin[MAXLINE] = "/usr/bin/";
		strcat(cwd, arguments[0]);
		strcat(usr_bin, arguments[0]);
		
		// Fork() a new process to run the file descriptor.
		pid_t pid = fork();
		
		// Upon fork() failure, return to main.
		if(pid == -1) { return; }
		
		// Handle file redirection in the child process.
		if(pid == 0)
		{
			// Put the child in a new process group before calling exec in the helper functions.
			// If we cannot create a new process group, exit immediately.
			int pgid = setpgid(0,0);
			if(pgid < 0) { exit(1); }
			
			// File descriptor variables.
			int fd = -1;
			int fd2 = -1;
			int failed = 0;
		
			// Below are the four if-statements describing the conditions for file redirection cases.
			// If we are opening for writing (> = 1 = io), changing STDOUT, out_file != NULL, in_file = NULL and is_append = 0.
			if(out_file != NULL && in_file == NULL && is_append == 0)
			{
				// Open the file for writing (overwrite), create the file if it does not exist.
				// If we cannot open the file, we immediately exit the process.
				fd = open(out_file, O_WRONLY | O_TRUNC | O_CREAT, 0600);
				if(fd == -1)
				{
					// Call appropriate logging function.
					log_file_open_error(out_file);
					exit(1);
					
				}
				
				// Call helper function w/ io = 1 to indicate we are using ">".
				failed = exec_file_redirection(arguments, fd, 1, cwd, usr_bin);
				
				// Close the file.
				close(fd);
					
				// If the command was invalid (failure), call the appropriate logging function.
				// Check if background or foreground to distinguish which list is needed for the log.
				if(failed == -1)
				{
					if(is_bg == 0)
					{
						log_command_error(shell -> fg_list -> head -> cmd);
						exit(1);	
					}
					
					if(is_bg == 1)
					{
						log_command_error(command -> cmd);
						exit(1);
					}
				}
					
				exit(0);
			}
			
			// If we are opening for appending (>> = 2 = io), changing STDOUT, out_file != NULL, in_file = NULL and is_append = 1.
			if(out_file != NULL && in_file == NULL && is_append == 1)
			{
				// Opening the file for appending, create the file if it does not exist.
				// If we cannot open the file, we immediately exit the process.
				fd = open(out_file, O_WRONLY | O_APPEND | O_CREAT, 0600);
				if(fd == -1)
				{
					// Call the appropriate logging function.
					log_file_open_error(out_file);
					exit(1);
				}
				
				// Call helper function w/ io = 2 to indicate we are using ">>".
				failed = exec_file_redirection(arguments, fd, 2, cwd, usr_bin); 
					
				// Close the file.
				close(fd);
				
				// If the command was invalid (failure), call the appropriate logging function.
				// Check if background or foreground to distinguish which list is needed for the log.
				if(failed == -1)
                                {
                                        if(is_bg == 0)
                                        {
                                                log_command_error(shell -> fg_list -> head -> cmd);
                                                exit(1);
                                        }

                                        if(is_bg == 1)
                                        {
                                                log_command_error(command -> cmd);
                                                exit(1);
                                        }
                                }
					
				exit(0);
			}
			
			// If we are opening for reading (< = 3 = io), changing STDIN, in_file != NULL, out_file = NULL, is_append = -1.
			if(in_file != NULL && out_file == NULL && is_append == -1)
			{
				fd = open(in_file, O_RDONLY);
				if(fd == -1)
				{
					// Call appropriate logging function.
					log_file_open_error(in_file);
					exit(1);
				}
				
				// Call our helper function w/ io = 3 to indicate we are using "<".
				failed = exec_file_redirection(arguments, fd, 3, cwd, usr_bin);
				
				// Close the file.
				close(fd);
				
				// If the command was invalid (failure), call the appropriate logging function.
				// Check if background or foreground to distinguish which list is needed for the log.
				if(failed == -1)
                                {
                                        if(is_bg == 0)
                                        {
                                                log_command_error(shell -> fg_list -> head -> cmd);
                                                exit(1);
                                        }

                                        if(is_bg == 1)
                                        {
                                                log_command_error(command -> cmd);
                                                exit(1);
                                        }
                                }
					
				exit(0);
			}
			
			// If we have double file redirection (< and > or < and >>).
			if(in_file != NULL && out_file != NULL && (is_append == 0 || is_append == 1))
			{
				// If we have (< and >).
				if(is_append == 0)
				{
					// We need to open the in_file for reading only and the out_file for writing, truncating, and creating.
					fd = open(in_file, O_RDONLY);
					fd2 = open(out_file, O_WRONLY | O_TRUNC | O_CREAT, 0600);
				}
				
				// If we have (< and >>).
				else if(is_append == 1)
				{
					// Open in_file for reading and out_file for writing, appending, and creating.
					fd = open(in_file, O_RDONLY);
					fd2 = open(out_file, O_WRONLY | O_APPEND | O_CREAT, 0600);
				}
				
				// If either file cannot be opened call the appropriate logging function.
				if(fd == -1) { log_file_open_error(in_file); exit(1); }
				else if (fd2 == -1) { log_file_open_error(out_file); exit(1); }
				
				// Call helper function (io not needed here as both STDOUT and STDIN are modified for both cases).
				failed = mult_redirects(arguments, fd, fd2, cwd, usr_bin);
				
				// Close files.
				close(fd);
				close(fd2);
				
				// Check for invalid commands for either case.
				// Check if background or foreground to distinguish which list is needed for the log.
				if(failed == -1)
                                {
                                        if(is_bg == 0)
                                        {
                                                log_command_error(shell -> fg_list -> head -> cmd);
                                                exit(1);
                                        }

                                        if(is_bg == 1)
                                        {
                                                log_command_error(command -> cmd);
                                                exit(1);
                                        }
                                }
					
				exit(0);
			}
			
			// If we reach this point, there was no valid redirection.
			exit(1);	
		}
		
		// Parent handling of file redirection.
		else
		{
			// Check if the job is running in the foreground.
			if(is_bg == 0)
			{
				// Set the PID of the child process.
				//command -> pid = pid;
				shell -> fg_list -> head -> pid = pid;
				
				// Call the log function to indicate start of fg job.
				log_start_fg(shell -> fg_list -> head -> pid, shell -> fg_list -> head -> cmd);
				
				// Wait for the foreground process to finish.
				while(shell -> fg_list -> head != NULL)
				{
					// Do nothing...
				}
				
				return;
			}
			
			// Else, handle the background job.
			else
			{	
				// Set the pid of the child process.
				command -> pid = pid;
				
				// Inidicate the start of the background job.
				log_start_bg(command -> pid, command -> cmd);
					
				return;
			}
		}
		
		return;
}


/* Handles file redirection with both an input and output file.
 * Returns -1 if there is an invalid command, 0 if it is a success.
 */
int mult_redirects(char *arguments[], int fd_in, int fd_out, char *cwd, char *usr_bin) {
	
	// If arguments is NULL, return an error.
	if(arguments == NULL) { return -1; }
	
	// Make backups for input and output streams.
	int in_backup = 0;
	int out_backup = 0;
	
	// Use dup() to make a copy of input and output streams.
	in_backup = dup(STDIN_FILENO);
	out_backup = dup(STDOUT_FILENO);	
	
	// Use dup2 to redirect standard in and out streams.
	dup2(fd_in, STDIN_FILENO);
	dup2(fd_out, STDOUT_FILENO);
	
	// Use execv to see if our command is valid.
	// exec returns only on errors (invalid command).
	if(execv(cwd, arguments))
	{
		if(execv(usr_bin, arguments) < 0)
		{
			// Replace both our changed output/input streams before returning.
			dup2(in_backup, STDIN_FILENO);
			dup2(out_backup, STDOUT_FILENO);
			
			return -1;
		}
	}		
	
	return 0;
}

/* Finds the most recent background job (the one most recently added to the bg job list).
 * It will be the head if there were no previous background jobs.
 * Otherwise, it will be the last entry in the list.
 * Returns the most recent background command entry or NULL upon error (if the list is empty).
 */
Command *get_bg_job() {

	// If the number of the jobs in the list is 1, we can grab the head of the list.
	if(shell -> bg_list -> count == 1)
	{
		return shell -> bg_list -> head;
	}
	
	// Else if there is more than 1 job, we need to find the last entry in the list (that will be
	// our most recently added background job and the one we need to execute).
	if(shell -> bg_list -> count > 1)
	{
		// Grab the head of bg job list.
		Command *head = shell -> bg_list -> head;
		
		// Iterate until we find the last node.
		while(head != NULL)
		{
			// When we find the node whose next is NULL, we know we are at the last entry in the list
			// and thus our most recently added background command.
			if(head -> next == NULL)
			{
				return head;
			}
			
			// Move to the next node.
			head = head -> next;
		}			
	}
	
	return NULL;
} 


/* Handles non-built in jobs the user types into the command line.
 * Note: arguments[] is argv[] from main (contains the built-in commands and options).
 */
void handle_non_built_ins(char *arguments[], char *arguments2[], int is_bg, int is_append, int control, char *in_file, char *out_file) {
	
	// If arguments OR arguments2 is NULL, return to main.
	if(arguments == NULL || arguments2 == NULL) { return; }
	
	// Always grab the background job.
	Command *command = get_bg_job();

	// If our background command is NULL AND we have a background job, we want to return to main.
	if(is_bg == 1 && command == NULL) { return; }
	
	// If we have either an input or output pointer (e.g. not NULL), we know we are dealing with redirection of some sort (w/ non-built-ins).
	if(in_file != NULL || out_file != NULL)
	{
		// Handle file redirection in above function.
		handle_file_redirection(arguments, is_bg, is_append, in_file, out_file);
		return;
	}

	// String for our current working directory and /usr/bin/.
	char cwd[MAXLINE] = "./";
	char usr_bin[MAXLINE] = "/usr/bin/";
	
	// Concatenate our user command to end of each path above.
	strcat(cwd, arguments[0]);
	strcat(usr_bin, arguments[0]);
	
	// Check if we have control operators to handle.
	if(control == 1 || control == 2)
	{
		// Initialize these for the control operators(&& = 1 or || = 2).
		// Create additional strings for our current working directory and /usr/bin/ for argv2.		
		char cwd2[MAXLINE] = "./";
		char usr_bin2[MAXLINE] = "/usr/bin/";
		
		// Concatenate our user command to the end of each path.	
		strcat(cwd2, arguments2[0]);
		strcat(usr_bin2, arguments2[0]);
		
		sigset_t mask, prev_mask;
        	sigaddset(&mask, SIGCHLD);
        	sigprocmask(SIG_BLOCK, &mask, &prev_mask);
		
		// Call helper functions.
		handle_control_operators(arguments, arguments2, cwd, cwd2, usr_bin, usr_bin2, is_bg, control);
		
		sigprocmask(SIG_SETMASK, &prev_mask, NULL);
		return;
	}
	
	// Fork() this process to run the user command.
	pid_t pid = fork();
	
	// Upon fork() failure, return to main.
	if(pid == -1) { return; }
	
	if(pid != 0)
	{
		// Check if this job is in the foreground.
		if(is_bg == 0)
		{
			// Set the pid of the child process.
			shell -> fg_list -> head -> pid = pid;
		
			// Call the foreground log function.
			log_start_fg(shell -> fg_list -> head -> pid, shell -> fg_list -> head -> cmd);
			
			// Wait for the foreground process to finish.	
			while(shell -> fg_list -> head != NULL)
			{
				// Do nothing...
			}
			
			return;
		}
		
		// Else, handle the background job.
		else
		{	
			// Set the pid of the child process.
			command -> pid = pid;
			
			// Indicate start of background log function.
			log_start_bg(command -> pid, command -> cmd);
			
			// Exit the function, we will reap the children as they come in the sigchld handler.
			return;
		}
	}
	
	// The child will run the user's command (job).
	else
	{
		// Put the child in a new process group.
		// If we cannot create a new process group, exit immediately.
		int pgid = setpgid(0,0);
		if(pgid < 0) { exit(1); }
		
		// Check to see if the the given command is invalid.
		if(execv(cwd, arguments) < 0)
		{
			if(execv(usr_bin, arguments) < 0)
			{
				// If we are executing an invalid foreground command.
				if(is_bg == 0)
				{
					// Since the program was not found in the current working directory or usr/bin
					// we call the appropriate logging function and exit the function.
					log_command_error(shell -> fg_list -> head -> cmd);
			
					exit(1);
				}
				
				// If we are executing an invalid background command.
				if(is_bg == 1)
				{
					// Report invalid background command.
					log_command_error(command -> cmd);
					
					exit(1);		
				}
			}
		}
		
		exit(0);
	}
	
	return;
}

/* Function for handling control operators specified with commands IN THE FOREGROUND ONLY. */
void handle_control_operators(char *arguments[], char *arguments2[], char *cwd, char *cwd2, char *usr_bin, char *usr_bin2, int is_bg, int control) {
	
	// If any of the pointer arguments are NULL, return to caller (then return to main).
	if(arguments == NULL || arguments2 == NULL || cwd == NULL || cwd2 == NULL || usr_bin == NULL || usr_bin2 == NULL) { return; }
		
	// If we are handling background control operators:
	if(is_bg == 1)
	{
		// Call helper function.
		handle_bg_control_operators(arguments, arguments2, cwd, cwd2, usr_bin, usr_bin2, is_bg, control);
		return;	
	}
	
	// Track child status.
	int child_status;
	
	// Fork() to run commands.
	pid_t pid = fork();
		
	// Upon fork() failure, return to main.
	if(pid == -1) { return; }
	
	// Handle control operators in child.
	if(pid == 0)
	{
		// Put the child in a new process group.
		// If we cannot create a new process group, exit immediately.
		int pgid = setpgid(0,0);
		if(pgid < 0) { exit(1); }
		
		// Launch the first command in cwd and usr_bin.
		if(execv(cwd, arguments) < 0)
		{		
			if(execv(usr_bin, arguments) < 0)
			{
				// If the first job fails because the command was invalid, call the appropriate logging function
				// and exit(1) to indicate we do not need to run the 2nd command to our parent.
				log_command_error(shell -> fg_list -> head -> cmd);
				exit(1);
			}
		}
	}	
	
	// Else, handle child in parent.
	else if(pid != 0)
	{	
		// Set the pid of the process.
		shell -> fg_list -> head -> pid = pid;
		
		// Call the foreground log function.
		log_start_fg(shell -> fg_list -> head -> pid, shell -> fg_list -> head -> cmd);
		
		// Wait for the child to terminate.
		// This will be for the entire command (cmd1 && cmd2 OR cmd1 || cmd2).
		while(pid == waitpid(pid, &child_status, WUNTRACED))
		{
			// If pid is invalid, we need to reloop.
			if(pid == -1) { continue; }
			
			// See if the child terminated normally.
			if(WIFEXITED(child_status))
			{	
				// If the first command terminated abnormally (exit_status == 1).
				// && => DO NOT run 2nd command. (EX: my_echo 1 && my_echo 0)
				// || => RUN 2nd command. (EX: my_echo 1 || my_echo 367/0)
				if(WEXITSTATUS(child_status) == 1)
				{ 
					// If the first command terminated abnormally (exit_status == 1),
					// we should end up back in here from sigchld_handler().
					// For ||, RUN the 2nd command.
					if(control == 2)
					{
						// Child status for 2nd fork().
						int child_status_or2;
					
						// Fork() for the 2nd command.
						pid_t pid2 = fork();
					
						// Upon fork() failure, return to main.
						if(pid2 == -1) { return; }
					
						// Run the command in the child.
						if(pid2 == 0)
						{
							// Set create a new process group for this child.
							// If this cannot be created, exit immediately.
							int pgid2 = setpgid(0,0);
							if(pgid2 < 0) { exit(1); }
					
							if(execv(cwd2, arguments2) < 0)
							{
								if(execv(usr_bin2, arguments2) < 0)
								{
									// If the 2nd command is invalid, call log_command_error.
									log_command_error(shell -> fg_list -> head -> cmd);
									exit(1);
								}
							}
							
							exit(0);
						}
					
						// Handle child in parent.
						else
						{
		
							// Use the pid of 2nd command, call the appropriate logging function to indicate the 2nd process starts.
							log_or_list(shell -> fg_list -> head -> pid, pid2, shell -> fg_list -> head -> cmd);
							
							// Wait for the 2nd command to finish.
							while(pid2 == waitpid(pid2, &child_status_or2, WUNTRACED))
							{
								// If pid2 is invalid, reloop.
								if(pid2 == -1) { continue; }
							
								if(WIFEXITED(child_status_or2))
								{
									// If the 2nd command succeeds (this code is back in the parent).
									// Set the job's execution status to "Stopped".
									strcpy(shell -> fg_list -> head -> exec_status, "Stopped");
									
									// Call the log function to indicate this process is done.
									// Deallocate memory for the command (removes it from our data structure).
									log_job_fg_term(shell -> fg_list -> head -> pid, shell -> fg_list -> head -> cmd);
									free_command_fg();
								
									return;
								}
							}		
						}
					}
				
					// For &&, DO NOT run the 2nd command.
					if(control == 1)
					{
						// Call appropriate logging function.
						log_and_list(shell -> fg_list -> head -> pid, -1, shell -> fg_list -> head -> cmd);
					
						// Notify user the job terminated normally.
						log_job_fg_term(shell -> fg_list -> head -> pid, shell -> fg_list -> head -> cmd);
					
						// Deallocate memory for the command.
						free_command_fg();
						
						return;	
					}	
				}
			
			
				// If the first commmand terminated normally (exit status == 0):
				// && => Run the 2nd command. (EX: my_echo 0 && my_echo 1)
				// || => DO NOT run the 2nd command.  (EX: my_echo 0 || my_echo 1)
				if(WEXITSTATUS(child_status) == 0)
				{
					
					// For ||, if the first command terminates normally, we can stop executing.
					if(control == 2)
					{
						// Call the appropriate logging function to indicate we are stopping after execution after
						// the first command.
						log_or_list(shell -> fg_list -> head -> pid, -1, shell -> fg_list -> head -> cmd);
						
						// Notify the user the job terminated normally.
						log_job_fg_term(shell -> fg_list -> head -> pid, shell -> fg_list -> head -> cmd);
				
						// Deallocate memory for the command (remove from fg list).
						free_command_fg();
					
						return;
					}
				
					if(control == 1)
					{
						// Child status for 2nd fork().
						int child_status_and2;
				
						// Fork() for the 2nd command.
						pid_t pid2 = fork();
					
						// Upon fork() failure, return to main.
						if(pid2 == -1) { return; }
				
						// Run the command in the child.
						if(pid2 == 0)
						{
							// Create a new process group for this child.
							int pgid2 = setpgid(0,0);
							if(pgid2 < 0) { exit(1); }
							
							// Run the 2nd commmand.
							if(execv(cwd2, arguments2) < 0)
							{
								if(execv(usr_bin2, arguments2) < 0)
								{
									// If the 2nd command is invalid, call log_command_error.
									log_command_error(shell -> fg_list -> head -> cmd);
									exit(1);
								}
							}
						}
				
						// Handle child in parent.
						else
						{	
							// Use the pid of the 2nd command, call the appropriate logging function to indicate
							// the 2nd process starts.
							log_and_list(shell -> fg_list -> head -> pid, pid2, shell -> fg_list -> head -> cmd);
							
							// Wait for the 2nd command to finish.
							while(pid2 == waitpid(pid2, &child_status_and2, WUNTRACED))
							{
								// If PID2 is invalid, we need to reloop.
								if(pid2 == -1) { continue; }
								
								if(WIFEXITED(child_status_and2))
								{	
									// If the 2nd command succeeds (this code is back in the parent).
									// Set the job's execution status to "Stopped".
									strcpy(shell -> fg_list -> head -> exec_status, "Stopped");
					
									// Call the log function to indicate this process is done.
									// Deallocate memory for the command (removes it from our data structure).
									log_job_fg_term(shell -> fg_list -> head -> pid, shell -> fg_list -> head -> cmd);
									free_command_fg();
									
									return;
								}
								
								// TODO: THIS WILL BE TESTED FIX IT AFTER YOU GOT EVERYTHING ELSE DOWN.	
								// TODO: THIS WILL BE TESTED, IT DOES NOT PROPERLY HANDLE HITTING CONTROL ^C FOR THE 2ND PROCESS (ALSO NEED TO PUT THIS IN THE IF FOR ORs WHEN YOU FIGURE OUT A SOLUTION).
								if(WIFSIGNALED(child_status_and2))
								{	
									if(WTERMSIG(child_status_and2) == SIGINT)
									{
										log_job_fg_term_sig(shell -> fg_list -> head -> pid, shell -> fg_list -> head -> cmd);
										
										shell -> fg_list -> head = shell -> fg_list -> head -> next;
										
										return;	
									}
								}
							}	
						}
					}
				} 
			} 
		}
	}

	return;
}


/* Function for handling use of control operators for background processes. */
void handle_bg_control_operators(char *arguments[], char *arguments2[], char *cwd, char *cwd2, char *usr_bin, char *usr_bin2, int is_bg, int control) {
	
	// If any of the pointer arguments are NULL, return to caller (then return to main).
	if(arguments == NULL || arguments2 == NULL || cwd == NULL || cwd2 == NULL || usr_bin == NULL || usr_bin2 == NULL) { return; }
	
	// Grab the background command.
	Command *command = get_bg_job();
	
	// If the background job is NULL. We want to return from this function.
	if(command == NULL) { return; }
	
	// Copy the directories for execution into global variables that are accessible inside SIGCHLD handler.	
	int i = 0;
	for(i = 0; i < MAXLINE; i++)
	{
		g_cwd2[i] = cwd2[i];
		g_usr_bin2[i] = usr_bin2[i];	
	}
	
	// Fork() to run commands.
	pid_t pid = fork();
	
	// Upon fork() failure, return to main.
	if(pid == -1) { return; }
	
	// Handle control operators in child.
	if(pid == 0)
	{
		// Put the child in a new process group.
		// If we cannot create a new process group, exit immediately.
		int pgid = setpgid(0,0);
		if(pgid < 0) { exit(1); }
		
		// Launch the first command in cwd and usr_bin.
		if(execv(cwd, arguments) < 0)
		{
			if(execv(usr_bin, arguments) < 0)
			{
				// If the first jobs fails, call logging functions and exit with code 1.
				log_command_error(command -> cmd);
				exit(1);
			}
		}
	}
	
	// Else, handle the child in the parent.
	else if(pid != 0)
	{
		// Set the pid of the command;
		command -> pid = pid;
		
		// Call the background log function.
		log_start_bg(command -> pid, command -> cmd);
	}
	
	return;
}

/* Deallocate memory for finished background jobs. */
void free_command_bg(Command *command) {
	
	// If command is already NULL, return.
	if(command == NULL) { return; }
		
	// Deallocate memory for the exec_status, user command, and command itself.
	free(command -> exec_status);
	free(command -> cmd);
	free(command);
	
}

/* Deallocate the memory for finished foreground jobs. */
void free_command_fg() {
	
	// Save the head of the fg job list.
	Command *head = shell -> fg_list -> head;
	
	// Deallocate memory for the exec_status, user command and the command itself.
	free(head -> exec_status);
	free(head -> cmd);
	free(head);
	
	// Decrement the count for the fg job list.
	shell -> fg_list -> count--;
	
	// Set the head of the list to NULL to indicate it's empty.
	shell -> fg_list -> head = NULL;
}

/* Helper function for shell_free that deallocates jobs in FG and BG. */
void dealloc_lists(Command *head) {
	
	// If head is NULL, return to caller.
	if(head == NULL) { return; }
	
	// Store incoming head of List.
	Command *cur = head;
	
	// Temp node for deallocation help.
	Command *temp = NULL;
	char *cmd = NULL;
	char *exec_status = NULL;
	
	// Free all nodes in the list.
	while (cur != NULL)
	{
		// Store current node in temp.
		// Store temp's job command (cmd).
		// Move to next node.
		// Free previous node and & job command.
		temp = cur;
		cmd = temp -> cmd;
		exec_status = temp -> exec_status;
		cur = cur -> next;
		free(temp);
		free(cmd);
		free(exec_status);
	}
	
	// Set the head the List to NULL.
	cur = NULL;
	return;
}


/* Frees allocated memory in the shell.
 * Deallocates memory from the inside out. */
void shell_free(Jobs *shell) {
	
	// If shell is NULL, exit the program (we cannot do anything at this point).
	if(shell == NULL) { exit(1); }
	
	// Deallocate memory for fg_list.
	dealloc_lists(shell -> fg_list -> head);
	free(shell -> fg_list);
	
	// Deallocate memory for bg_list.
	dealloc_lists(shell -> bg_list -> head);
	free(shell -> bg_list);
	
	// Deallocate memory for shell.
	free(shell);
	
	return;
}

